// Code mostly generated by Claude.ai
// Board: Sparkfun Pro Micro
// Pinout link: https://learn.sparkfun.com/tutorials/pro-micro--fio-v3-hookup-guide/hardware-overview-pro-micro
// Programmer: Arduino IDE 2.3.4

// Todo:
//  -fix the oled on/off
//  -make the oled on/off button disable the other LEDs when held, but then turn back on if the reset button is hit
//  -add a confirmation dialog box when trying to reset the counter - or remove it when ready to use
//  -change formatting and style
//  -design case?
//  -make oled timeout

#include <ss_oled.h> // https://github.com/bitbank2/ss_oled
#include <EEPROM.h>
#include <Wire.h>

// OLED Display settings
#define SDA_PIN 2
#define SCL_PIN 3
#define FLIPPED 0
#define INVERTED 0
#define OLED_ADDR 0x3C
#define RESET_PIN -1
#define OLED_TYPE OLED_128x32

// Button pins
#define BUTTON_A 4
#define BUTTON_B 5
#define BUTTON_C 15

// LED pins
#define LED_GREEN 9
#define LED_RED 10
#define OLED_VCC 16

// EEPROM address for storing count
#define COUNT_ADDR 0

// Button timing
#define BUTTON_A_LONG_PRESS_TIME 2000  // Adjusted to 2 seconds for more accurate long press
#define BUTTON_B_LONG_PRESS_TIME 2000  // 2 second for Button B long press
#define DISPLAY_UPDATE_INTERVAL 500  // Update display every 500ms instead of 250ms
#define BUTTON_DEBOUNCE_TIME 50  // 50ms debounce time

// Global variables
SSOLED oled;
unsigned long startTime = 0;
unsigned long pausedTime = 0;
unsigned long timerDuration = 5000; // Initial 5 seconds in milliseconds
unsigned long baseTimerDuration = 5000; // Must compensate based on TIME_CORRETION
unsigned long timerDurationIncrement = 10000; // Must compensate based on TIME_CORRETION
bool isRunning = false;
bool isPaused = false;
bool oledEnabled = true;
bool buttonAPressed = false;
bool buttonBPressed = false;
bool buttonCPressed = false;
int restartCount = 0;
unsigned long buttonAPressTime = 0;
unsigned long buttonBPressTime = 0;
unsigned long buttonCPressTime = 0;
unsigned long lastUpdateTime = 0;
char lastLine1[20] = "";
char lastLine2[20] = "";

// Time correction factor
const float TIME_CORRECTION = 0.5; // Multiply durations by 2 to compensate for faster clock

void saveCount() {
  EEPROM.put(COUNT_ADDR, restartCount);
}

void loadCount() {
  EEPROM.get(COUNT_ADDR, restartCount);
  if (restartCount < 0 || restartCount > 9999) {
    restartCount = 0;
    saveCount();
  }
}

void updateDisplay(const char* line1, const char* line2, bool forceUpdate = false) {
  // Only update if text has changed or force update is requested
  if (forceUpdate || strcmp(line1, lastLine1) != 0 || strcmp(line2, lastLine2) != 0) {
    // Clear lines individually
    oledWriteString(&oled, 0, 0, 0, "                ", FONT_NORMAL, 0, 1);
    oledWriteString(&oled, 0, 0, 2, "                ", FONT_NORMAL, 0, 1);
    // Write new text
    oledWriteString(&oled, 0, 0, 0, line1, FONT_NORMAL, 0, 1);
    oledWriteString(&oled, 0, 0, 2, line2, FONT_SMALL, 0, 1);
    // Update last known text
    strcpy(lastLine1, line1);
    strcpy(lastLine2, line2);
  }
}

void initDisplay() {
  Wire.begin();
  delay(200);  // Increased delay for more stable initialization
  
  // Initialize OLED
  int rc = oledInit(&oled, OLED_TYPE, OLED_ADDR, FLIPPED, INVERTED, 1, SDA_PIN, SCL_PIN, RESET_PIN, 400000L);
  // Clear display and set contrast
  oledFill(&oled, 0, 1);
  delay(200);
  oledSetContrast(&oled, 127);
  delay(200);
  
  // Show splash screen
  oledWriteString(&oled, 0, 0, 0, "Hello!", FONT_NORMAL, 0, 1);
  delay(2000);
  
  // Show ready screen
  char countStr[20];
  sprintf(countStr, "Count: %d", restartCount);
  updateDisplay("Ready to go!", countStr, true);
}

// Helper function to format time as MM:SS
void formatTime(unsigned long seconds, char* buffer) {
  unsigned long minutes = seconds / 60;
  unsigned long remainingSeconds = seconds % 60;
  sprintf(buffer, "%lu:%02lu", minutes, remainingSeconds);
}

void setup() {
  // Initialize buttons
  pinMode(BUTTON_A, INPUT_PULLUP);
  pinMode(BUTTON_B, INPUT_PULLUP);
  pinMode(BUTTON_C, INPUT_PULLUP);
  pinMode(LED_GREEN, OUTPUT);
  pinMode(LED_RED, OUTPUT);
  pinMode(OLED_VCC, OUTPUT);
  digitalWrite(OLED_VCC, HIGH);

  // Load saved count
  loadCount();
  
  // Initialize display
  initDisplay();
}

void loop() {
  static unsigned long lastSecondUpdate = 0;
  unsigned long currentMillis = millis();
  
  // Set LED states
  if (isRunning) {
    digitalWrite(LED_GREEN, LOW);
    digitalWrite(LED_RED, HIGH);
  } else if (!isPaused) {
    digitalWrite(LED_GREEN, HIGH);
    digitalWrite(LED_RED, LOW);
  }
  // if (oledEnabled) {
  //   digitalWrite(OLED_VCC, HIGH);
  // } else {
  //   digitalWrite(OLED_VCC, LOW);
  // }

  // Read button states
  bool currentButtonA = !digitalRead(BUTTON_A);
  bool currentButtonB = !digitalRead(BUTTON_B);
  bool currentButtonC = !digitalRead(BUTTON_C);
  
  // Button A handling with long press detection
  if (currentButtonA) {
    if (!buttonAPressed) {
      buttonAPressTime = currentMillis;
      buttonAPressed = true;
    } else if ((currentMillis - buttonAPressTime) >= BUTTON_A_LONG_PRESS_TIME) {
      // Reset counter
      restartCount = 0;
      saveCount();
      timerDuration = baseTimerDuration;
      isRunning = false;
      isPaused = false;
      
      char countStr[20];
      sprintf(countStr, "Count: %d", restartCount);
      updateDisplay("Counter Reset!", countStr, true);
      delay(1000);
      updateDisplay("Ready to go!", countStr, true);
      
      while (!digitalRead(BUTTON_A)) {
        delay(10);
      }
      buttonAPressed = false;
    }
  } else if (buttonAPressed) {
    if ((currentMillis - buttonAPressTime) < BUTTON_A_LONG_PRESS_TIME) {
      if (!isRunning && !isPaused) {
        startTime = currentMillis;
        isRunning = true;
        timerDuration = (unsigned long)(baseTimerDuration + timerDurationIncrement * restartCount); // Adjust timer duration
        restartCount++;
        saveCount();
        lastSecondUpdate = currentMillis;
      } else if (isPaused) {
        startTime = currentMillis - (pausedTime / TIME_CORRECTION); // Adjust paused time
        isPaused = false;
        isRunning = true;
        lastSecondUpdate = currentMillis;
      }
    }
    buttonAPressed = false;
  }
  
  // Button B handling with long press for timer end
  if (currentButtonB) {
    if (!buttonBPressed) {
      buttonBPressTime = currentMillis;
      buttonBPressed = true;
    } else if ((currentMillis - buttonBPressTime) >= BUTTON_B_LONG_PRESS_TIME && isRunning) {
      // End timer and increment counter
      isRunning = false;
      isPaused = false;
      timerDuration = baseTimerDuration;
      // restartCount++;
      saveCount();
      
      char countStr[20];
      sprintf(countStr, "Count: %d", restartCount);
      updateDisplay("Timer ended!", countStr, true);
      delay(1000);
      
      while (!digitalRead(BUTTON_B)) {
        delay(10);
      }
    }
  } else if (buttonBPressed) {
    if ((currentMillis - buttonBPressTime) < BUTTON_B_LONG_PRESS_TIME) {
      // Regular short press behavior for pause
      if (isRunning && !isPaused) {
        pausedTime = (currentMillis - startTime) * TIME_CORRECTION;
        isPaused = true;
        isRunning = false;
      }
    }
    buttonBPressed = false;
  }
  
  // Button C handling with debounce
  if (currentButtonC) {
    if (!buttonCPressed) {
      buttonCPressTime = currentMillis;
      buttonCPressed = true;
    }
  } else if (buttonCPressed && (currentMillis - buttonCPressTime) >= BUTTON_DEBOUNCE_TIME) {
    buttonCPressed = false;
    oledEnabled = !oledEnabled;
    
    // Control display visibility using contrast
    if (oledEnabled) {
      oledSetContrast(&oled, 127);  // Full contrast
    } else {
      oledSetContrast(&oled, 0);    // Zero contrast (display appears off)
    }
  }

  // Update display if needed
  if (currentMillis - lastUpdateTime >= DISPLAY_UPDATE_INTERVAL) {
    char timeStr[20];
    char countStr[20];
    char formattedTime[20];
    sprintf(countStr, "Count: %d", restartCount);
    
    if (isRunning) {
      unsigned long elapsed = (currentMillis - startTime) * TIME_CORRECTION;
      
      if (elapsed >= timerDuration) {
        isRunning = false;
        timerDuration = baseTimerDuration;
        updateDisplay("Time's up!", countStr);
      } else {
        unsigned long remainingSeconds = ((timerDuration - elapsed + 999) / 1000); // Round up
        formatTime(remainingSeconds, formattedTime);
        sprintf(timeStr, "Time: %s", formattedTime);
        updateDisplay(timeStr, countStr);
      }
    } else if (isPaused) {
      unsigned long remainingSeconds = ((timerDuration - pausedTime + 999) / 1000); // Round up
      formatTime(remainingSeconds, formattedTime);
      sprintf(timeStr, "Paused: %s", formattedTime);
      updateDisplay(timeStr, countStr);
    }
    
    lastUpdateTime = currentMillis;
  }
  
  delay(20);
}
